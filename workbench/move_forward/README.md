## move forward
### LHS RHS

LHS Left Hand Side 赋值操作的左侧
RHS Right Hand Side 赋值操作的右侧

If you want to give something like a variable or function a value,you will use LHS.
If you want to get value from something,use RHS.

LHS 侧重点在于赋值操作 可以理解为将值赋值给 = 左侧的这个东西，这个东西是啥，我不关心，反正就在作用域里找他呗，这层找不到就往上找，最后找不到就在全局里面创建个就完事了，反正我要完成赋值操作

RHS 侧重点在于查找 可以理解为我要找到这个变量啊，这个作用域里找不到就往上找，最后找不到难受到报错 RefrenceError

LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“= 赋值操作符的左侧或右侧”。说白了就是变量出现在复制操作的左边是进行LHS查询，出现在右边就是进行RHS查询。

### C++ 左值 右值

左值引用 & ，是对左值进行绑定
右值引用 && ，是对右值进行绑定

区分左值和右值的一个简单办法是：**看能不能对表达式取地址，如果能则为左值，否则为右值**。

右值引用是 C++11 中新增加的一个很重要的特性，他主是要用来解决 C++98/03 中遇到的两个问题
- 第一个问题就是临时对象非必要的昂贵的拷贝操作；
- 第二个问题是在模板函数中如何按照参数的实际类型进行转发；

通过引入右值引用，很好的解决了这两个问题，改进了程序性能，后面将会详细介绍右值引用是如何解决这两个问题的。

在C++11中所有的值必属于左值、将亡值、纯右值三者之一。
比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等都是纯右值。
而将亡值是 C++11 新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&& 函数返回值、std::move 返回值和转换为 T&& 的类型的转换函数的返回值等。

通过右值引用临时值不会像正常右值那样，在表达式结束之后就销毁了，而是会被“续命”，他的生命周期将会通过右值引用得以延续，和引用变量的声明周期一样长。

常量左值引用是一个“万能”的引用类型，可以接受左值、右值、常量左值和常量右值。需要注意的是普通的左值引用不能接受右值。

右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。
右值引用的一个重要作用是用来支持移动语义。

注意的一个细节是，我们提供移动构造函数的同时也会提供一个拷贝构造函数，以防止移动不成功的时候还能拷贝构造，使我们的代码更安全。

我们知道移动语义是通过右值引用来匹配临时值的，那么，普通的左值是否也能借助移动语义来优化性能呢，那该怎么做呢？事实上C++11为了解决这个问题，提供了 std::move 方法来将左值转换为右值，从而方便应用移动语义。move 是将对象资源的所有权从一个对象转移到另一个对象，只是转移，没有内存的拷贝，这就是所谓的 move 语义。

使用move几乎没有任何代价，只是转换了资源的所有权。他实际上将左值变成右值引用，然后应用移动语义，调用移动构造函数，就避免了拷贝，提高了程序性能。
move 对于含资源（堆内存或句柄）的对象来说更有意义

### compile

```
g++ -std=c++17 -o move.out move.cpp
g++ -std=c++17 -o forward.out forward.cpp
g++ -std=c++17 -o move_construction.out move_construction.cpp
```

### Reference
- https://www.cnblogs.com/likaiming/p/9029908.html
- https://www.cnblogs.com/qicosmos/p/4283455.html
- https://www.cnblogs.com/taiyang-li/p/5894607.html
- https://blog.csdn.net/chenhaifeng2016/article/details/74192525
